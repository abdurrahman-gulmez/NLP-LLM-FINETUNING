[
  {
    "question_id": "abc365_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    first_max = -1\n    second_max = -1\n    \n    for num in arr:\n        if num > first_max:\n            second_max = first_max\n            first_max = num\n        elif first_max > num > second_max:\n            second_max = num\n            \n    print(second_max)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc365_a",
    "code_list": [
      "def main():\n    Y = int(input().strip())\n    \n    if (Y % 4 == 0 and Y % 100 != 0) or (Y % 400 == 0):\n        print(366)\n    else:\n        print(365)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    strings = data[1:1+n]\n    \n    # Find maximum length of all strings\n    max_len = max(len(s) for s in strings)\n    \n    # Create result list with empty strings\n    result = [''] * max_len\n    \n    # Process each string from longest to shortest\n    for s in reversed(strings):\n        if len(s) == 0:\n            continue\n            \n        # Add characters from the current string\n        for i in range(len(s)):\n            char = s[i]\n            if result[i] != '':\n                # Conflict - we can't add more characters here\n                return\n            result[i] += char\n        \n        # Add remaining asterisks\n        for j in range(i + 1, len(result)):\n            result[j] += '*'\n    \n    # Remove trailing asterisks\n    while result[-1].endswith('*'):\n        result.pop()\n    \n    # Print the result\n    for t in result:\n        print(t)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    T = int(data[1])\n    A = int(data[2])\n    \n    if (T - A) % 2 == 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_a",
    "code_list": [
      "def main():\n    A, B, C = map(int, input().split())\n    \n    # Check if there's any overlap between sleep period and shout period\n    if max(A, B) < min(C - 1, 23):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_b",
    "code_list": [
      "def main():\n    x = float(input().strip())\n    \n    # Convert to string and remove trailing zeros after decimal point\n    str_x = \"{:.3f}\".format(x)\n    # Remove trailing zeros and check if we need to add a decimal point\n    cleaned_str = str_x.rstrip('0').rstrip('.')\n    \n    print(cleaned_str)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    k = int(data[1])\n    arr = list(map(int, data[2:2+n]))\n    \n    result = []\n    for i in range(k):\n        result.append(arr[-(i+1)])\n    for i in range(n - k):\n        result.append(arr[i])\n        \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    if n == 1:\n        print(0)\n        return\n        \n    sorted_arr = sorted(arr, reverse=True)\n    total_decrements = 0\n    \n    for i in range(n):\n        if sorted_arr[i] > 1:\n            total_decrements += sorted_arr[i] - 1\n            \n    print(total_decrements)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_a",
    "code_list": [
      "def main():\n    A, B = map(int, input().split())\n    \n    # Check if A or B is even\n    if A % 2 == 0 or B % 2 == 0:\n        print(1)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    min_fatigue = float('inf')\n    \n    # Try all initial positions for the first key\n    for start_pos in range(101):\n        current_fatigue = 0\n        \n        # Process each note\n        for i in range(n):\n            pos = int(data[2*i + 1]) - 1\n            \n            # Calculate movement cost\n            move_cost = abs(start_pos - pos)\n            \n            # Update total fatigue\n            current_fatigue += move_cost\n            \n            # Update starting position for next iteration\n            if data[2*i + 2] == 'L':\n                start_pos = pos\n            else:\n                start_pos = pos + 1\n                \n        # Update overall minimum\n        if current_fatigue < min_fatigue:\n            min_fatigue = current_fatigue\n            \n    print(min_fatigue)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_a",
    "code_list": [
      "def main():\n    L, R = map(int, input().split())\n    \n    if L == 1 and R == 1:\n        print(\"Invalid\")\n    elif L == 1 or R == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    matrix = []\n    index = 1\n    for i in range(n):\n        row = list(map(int, data[index:index+n]))\n        matrix.append(row)\n        index += n\n    \n    current_element = 1\n    for i in range(n):\n        current_element = matrix[current_element - 1][i]\n    \n    print(current_element)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Initialize list to track which family has the earliest boy\n    earliest_boy_family = [None] * (n + 1)\n    \n    index = 2\n    for _ in range(m):\n        family_id = int(data[index])\n        gender = data[index + 1]\n        \n        if gender == 'M':\n            # This is a boy\n            if earliest_boy_family[family_id] is None:\n                # First boy in this family\n                earliest_boy_family[family_id] = True\n            elif earliest_boy_family[family_id]:\n                # Another boy in this family - not Taro\n                print(\"No\")\n                return\n                \n        index += 2\n        \n    # Check if all families have exactly one boy\n    for i in range(1, n + 1):\n        if earliest_boy_family[i] is None:\n            # Family without boys - not Taro\n            print(\"No\")\n            return\n            \n    # If we made it here, all families have exactly one boy - Taro!\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_a",
    "code_list": [
      "def main():\n    S_AB = input().strip()\n    S_AC = input().strip()\n    S_BC = input().strip()\n    \n    # Determine who is the oldest\n    if S_AB == '<':\n        oldest = 'A'\n    elif S_AB == '>':\n        oldest = 'C'\n    else:  # S_AB == '='\n        if S_AC == '<':\n            oldest = 'A'\n        elif S_AC == '>':\n            oldest = 'C'\n        else:  # S_AC == '='\n            oldest = 'B'\n    \n    # Determine who is the middle (second oldest)\n    if oldest == 'A':\n        if S_AC == '<':\n            middle = 'B'\n        elif S_AC == '>':\n            middle = 'C'\n        else:  # S_AC == '='\n            if S_BC == '<':\n                middle = 'B'\n            elif S_BC == '>':\n                middle = 'C'\n            else:  # S_BC == '='\n                middle = 'A'\n    elif oldest == 'B':\n        if S_BC == '<':\n            middle = 'C'\n        elif S_BC == '>':\n            middle = 'A'\n        else:  # S_BC == '='\n            if S_AC == '<':\n                middle = 'A'\n            elif S_AC == '>':\n                middle = 'C'\n            else:  # S_AC == '='\n                middle = 'B'\n    else:  # oldest == 'C'\n        if S_BC == '<':\n            middle = 'A'\n        elif S_BC == '>':\n            middle = 'B'\n        else:  # S_BC == '='\n            if S_AC == '<':\n                middle = 'A'\n            elif S_AC == '>':\n                middle = 'B'\n            else:  # S_AC == '='\n                middle = 'C'\n                \n    print(middle)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc372_a",
    "code_list": [
      "def main():\n    S = input().strip()\n    result = []\n    for char in S:\n        if char != '.':\n            result.append(char)\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_a",
    "code_list": [
      "def main():\n    strings = []\n    for _ in range(12):\n        strings.append(input().strip())\n    \n    count = 0\n    for i in range(1, 13):\n        if len(strings[i-1]) == i:\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Create mapping: char -> position\n    char_to_pos = {}\n    for i, ch in enumerate(s):\n        char_to_pos[ch] = i + 1\n    \n    # Initialize distances array\n    dist = [0] * 27\n    \n    # Process from 'A' to 'Z'\n    for pos in range(1, 27):  # positions 1 through 26\n        current_char = chr(ord('A') + pos - 1)\n        \n        # Calculate minimum distance to reach current position\n        min_dist = float('inf')\n        for prev_char in char_to_pos:\n            prev_pos = char_to_pos[prev_char]\n            if prev_pos < pos:\n                dist[pos] += (pos - prev_pos)\n            elif prev_pos > pos:\n                dist[pos] += (prev_pos - pos)\n            \n            # Update minimum distance\n            if dist[pos] < min_dist:\n                min_dist = dist[pos]\n        \n        # Add contribution from current character\n        dist[pos] += (ord(current_char) - ord('A'))\n    \n    # The answer is the sum of distances for positions 1 to 26\n    result = sum(dist[1:])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_b",
    "code_list": [
      "def main():\n    S = input().strip()\n    T = input().strip()\n    \n    min_length = min(len(S), len(T))\n    \n    for i in range(min_length):\n        if S[i] != T[i]:\n            print(i + 1)\n            return\n    \n    # If all characters match up to min_length, compare lengths\n    if len(S) == len(T):\n        print(0)\n    else:\n        print(min_length + 1)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    if s.endswith(\"san\"):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_b",
    "code_list": [
      "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    points = []\n    index = 1\n    for i in range(n):\n        x = int(data[index]); y = int(data[index+1])\n        index += 2\n        points.append((x, y))\n    \n    # Precompute distances between consecutive points\n    dist = [0] * n\n    for i in range(n):\n        dx = points[i][0] - points[(i+1) % n][0]\n        dy = points[i][1] - points[(i+1) % n][1]\n        dist[i] = (dx*dx + dy*dy)**0.5\n    \n    # Compute prefix sums for distance array\n    prefix = [0] * (n+1)\n    for i in range(1, n+1):\n        prefix[i] = prefix[i-1] + dist[i-1]\n    \n    # Find minimum spanning tree using Prim's algorithm\n    visited = [False] * n\n    min_tree = [0] * n\n    total_cost = 0.0\n    \n    # Start with first vertex\n    start_vertex = 0\n    visited[start_vertex] = True\n    current_edge = 0\n    \n    while current_edge < n:\n        min_dist = float('inf')\n        \n        # Try all edges connected to current vertex\n        for neighbor in range(n):\n            if not visited[neighbor]:\n                edge_cost = prefix[neighbor+1] - prefix[current_vertex]\n                if edge_cost < min_dist:\n                    min_dist = edge_cost\n                    min_tree[neighbor] = current_vertex\n        \n        # Add the closest edge to MST\n        total_cost += min_dist\n        current_vertex = min_tree[current_vertex]\n        visited[current_vertex] = True\n    \n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    count = 0\n    for i in range(n - 2):\n        if s[i] == '#' and s[i+2] == '#':\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc376_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    c = int(data[1])\n    times = list(map(int, data[2:2+n]))\n    \n    count = 0\n    current_time = 0\n    \n    for t in times:\n        if t - current_time >= c:\n            count += 1\n            current_time = t\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_b",
    "code_list": [
      "def main():\n    grid = []\n    for _ in range(8):\n        grid.append(input().strip())\n    \n    count = 0\n    \n    for i in range(8):\n        for j in range(8):\n            if grid[i][j] == '.':\n                valid = True\n                \n                # Check vertical capture\n                for k in range(8):\n                    if grid[k][j] != '.':\n                        valid = False\n                        break\n                \n                # Check horizontal capture\n                for k in range(8):\n                    if grid[i][k] != '.':\n                        valid = False\n                        break\n                \n                if valid:\n                    count += 1\n                    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Check if all characters are already correct\n    if s == \"ABC\":\n        print(\"Yes\")\n        return\n        \n    # Check if we have at least one 'A', one 'B', and one 'C'\n    has_A = 'A' in s\n    has_B = 'B' in s\n    has_C = 'C' in s\n    \n    if not (has_A and has_B and has_C):\n        print(\"No\")\n        return\n        \n    # Check if we can swap two adjacent characters to get \"ABC\"\n    for i in range(2):\n        if s[i] != 'A':\n            continue\n            \n        # Try swapping with B or C\n        if i < 2:  # Not last character\n            candidate = list(s)\n            candidate[i], candidate[i+1] = candidate[i+1], candidate[i]\n            if ''.join(candidate) == \"ABC\":\n                print(\"Yes\")\n                return\n                \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Precompute all remainders for each type\n    remainders = []\n    idx = 1\n    for _ in range(n):\n        q = int(data[idx]); r = int(data[idx+1]); idx += 2\n        remainder_set = set()\n        current = r\n        while True:\n            remainder_set.add(current)\n            current = (current + q) % q\n            if current == r:\n                break\n        remainders.append(remainder_set)\n    \n    # Process queries\n    q = int(data[idx]); idx += 1\n    results = []\n    for _ in range(q):\n        t = int(data[idx]); d = int(data[idx+1]); idx += 2\n        # Find smallest k >= d such that d mod q_t in remainders[t-1]\n        target_remainder = remainders[t-1].pop()  # Get one representative\n        found = False\n        for k in range(d, 10**18):  # Arbitrarily large upper bound\n            if k % n == t - 1 and k % q[t-1] == target_remainder:\n                results.append(str(k))\n                found = True\n                break\n        if not found:\n            results.append(\"impossible\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_a",
    "code_list": [
      "def main():\n    colors = [int(input()) for _ in range(4)]\n    freq = {}\n    \n    for color in colors:\n        if color not in freq:\n            freq[color] = 0\n        freq[color] += 1\n    \n    max_count = 0\n    for count in freq.values():\n        if count > max_count:\n            max_count = count\n            \n    print(max_count // 2)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, k = map(int, data[0].split())\n    s = data[1].strip()\n    \n    count = 0\n    max_count = 0\n    \n    for char in s:\n        if char == 'O':\n            count += 1\n        else:\n            count = 0\n            \n        if count >= k:\n            max_count += 1\n            \n    print(max_count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_a",
    "code_list": [
      "def main():\n    N = int(input().strip())\n    \n    # Extract digits\n    hundreds = N // 100\n    tens = (N // 10) % 10\n    units = N % 10\n    \n    # Form new numbers\n    num1 = 100 * tens + 10 * units + hundreds\n    num2 = 100 * units + 10 * hundreds + tens\n    \n    print(f\"{num1} {num2}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_a",
    "code_list": [
      "def main():\n    N = int(input().strip())\n    \n    # Convert to string to easily access individual digits\n    s = str(N)\n    \n    # Count occurrences of each digit\n    count_1 = s.count('1')\n    count_2 = s.count('2')\n    count_3 = s.count('3')\n    \n    # Check conditions\n    if count_1 == 1 and count_2 == 2 and count_3 == 3:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Find all occurrences of '|' and '-'\n    positions = []\n    for i, char in enumerate(s):\n        if char == '|':\n            positions.append(i)\n    \n    # If no '-' found, return empty sequence\n    if not positions:\n        print(0)\n        return\n    \n    # Calculate total length of sequence\n    n = len(s)\n    total_length = n - 1  # Subtract the last '|' position\n    \n    # Initialize result list\n    result = []\n    \n    # Process each segment between '|' characters\n    for i in range(len(positions)):\n        start_pos = positions[i]\n        if i < len(positions) - 1:\n            end_pos = positions[i + 1] - 1\n        else:\n            end_pos = total_length\n        \n        # Count number of '-' segments in this segment\n        count = 0\n        j = start_pos\n        while j <= end_pos:\n            if s[j] == '-':\n                count += 1\n            j += 1\n        \n        # Add count to result list\n        result.append(count)\n    \n    # Print the result\n    print(' '.join(map(str, result)))\n\nif __name__ == '__main__':\n    main()"
    ]
  },
  {
    "question_id": "abc381_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    if len(s) != n:\n        print(\"No\")\n        return\n        \n    # Check if first character is '1'\n    if s[0] != '1':\n        print(\"No\")\n        return\n        \n    # Check if last character is '/'\n    if s[-1] != '/':\n        print(\"No\")\n        return\n        \n    # Count '/' characters\n    slash_count = 0\n    for char in s:\n        if char == '/':\n            slash_count += 1\n            \n    # Calculate expected middle position\n    mid_pos = (n + 1) // 2\n    \n    # Check if middle position has exactly one '/' character\n    if slash_count == 1 and mid_pos <= n and mid_pos >= 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    n = len(s)\n    \n    # Check if length is even\n    if n % 2 != 0:\n        print(\"No\")\n        return\n    \n    # Count frequency of each character\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    \n    # Check if all characters appear exactly twice\n    for count in freq.values():\n        if count != 2:\n            print(\"No\")\n            return\n    \n    # Check if each pair of adjacent characters is the same\n    for i in range(n - 1):\n        if s[i] != s[i + 1]:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1]\n    \n    # Count initial empty boxes\n    empty_count = s.count('.')\n    \n    for _ in range(d):\n        # Find all positions with '@' within current window\n        positions = []\n        for i in range(n - d + 1):\n            if s[i] == '@':\n                positions.append(i)\n        \n        # Remove positions that are too far away from the window\n        valid_positions = [pos for pos in positions if pos >= d - 1 and pos <= n - d]\n        \n        # If no valid positions found, no change\n        if not valid_positions:\n            continue\n            \n        # Choose the first valid position (could be arbitrary choice)\n        chosen_pos = min(valid_positions)\n        \n        # Eat the cookie at chosen position\n        new_s = list(s)\n        new_s[chosen_pos] = '.'\n        s = ''.join(new_s)\n        \n        # Update empty count\n        empty_count += 1\n    \n    print(empty_count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1].strip()\n    \n    result = []\n    for i in range(n):\n        if s[i] == '@':\n            # Check if there's a cookie to the right\n            has_right_cookie = False\n            for j in range(i + 1, n):\n                if s[j] == '@':\n                    has_right_cookie = True\n                    break\n            \n            if not has_right_cookie:\n                result.append('.')\n            else:\n                result.append('@')\n        else:\n            result.append('.')\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc383_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    total_water = 0\n    current_time = 0\n    \n    idx = 1\n    while idx <= n:\n        t = int(data[idx]); v = int(data[idx+1])\n        idx += 2\n        \n        # Calculate how much water can be added during this interval\n        if t - current_time > 0:\n            max_add = min(v, t - current_time)\n            total_water += max_add\n            v -= max_add\n            current_time = t\n        \n        # If we still have water left, subtract 1 liter per second until we run out\n        if v > 0:\n            if t - current_time > 0:\n                v -= (t - current_time)\n                current_time = t\n            else:\n                v = 0\n                \n    print(total_water)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    r = int(data[1])\n    \n    idx = 2\n    results = []\n    \n    for _ in range(n):\n        d_i = int(data[idx]); a_i = int(data[idx + 1])\n        idx += 2\n        \n        if d_i == 1:  # Div. 1\n            if r >= 1600 and r <= 2799:\n                r += a_i\n        else:  # Div. 2\n            if r >= 1200 and r <= 2399:\n                r += a_i\n                \n        results.append(str(r))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0].strip())\n    c1 = data[1].strip()[0]\n    c2 = data[2].strip()[0]\n    s = data[3].strip()\n    \n    result = []\n    for char in s:\n        if char != c1:\n            result.append(c2)\n        else:\n            result.append(char)\n            \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_a",
    "code_list": [
      "def main():\n    A, B, C = map(int, input().split())\n    \n    total_sum = A + B + C\n    \n    if total_sum % 2 != 0:\n        print(\"No\")\n        return\n        \n    target = total_sum // 2\n    \n    # Check if we can form a subset with sum=target using only A's and B's\n    def can_form_subset_with_sum(target, count_A):\n        if target == 0:\n            return True\n            \n        if count_A < 0:\n            return False\n            \n        # Option 1: use current A\n        option1 = can_form_subset_with_sum(target - A, count_A - 1)\n        \n        # Option 2: skip current A\n        option2 = can_form_subset_with_sum(target, count_A - 1)\n        \n        return option1 or option2\n    \n    # We need to find at least one way to use all A's and some B's\n    for count_A in range(0, A + 1):\n        if can_form_subset_with_sum(target, count_A):\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_b",
    "code_list": [
      "from collections import deque\nimport sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    H, W, X, Y = map(int, data[0].split())\n    grid = []\n    for i in range(1, 1 + H):\n        grid.append(data[i].strip())\n    \n    T = data[-1]\n    \n    visited = [[False] * W for _ in range(H)]\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]  # U, D, L, R\n    \n    queue = deque()\n    queue.append((X-1, Y-1))\n    visited[X-1][Y-1] = True\n    \n    houses_passed = set()\n    houses_passed.add((X-1, Y-1))\n    \n    current_x, current_y = X-1, Y-1\n    \n    for char in T:\n        new_x, new_y = current_x, current_y\n        \n        if char == 'U':\n            new_y -= 1\n        elif char == 'D':\n            new_y += 1\n        elif char == 'L':\n            new_x -= 1\n        elif char == 'R':\n            new_x += 1\n            \n        if 0 <= new_x < H and 0 <= new_y < W and not visited[new_x][new_y]:\n            visited[new_x][new_y] = True\n            houses_passed.add((new_x, new_y))\n            current_x, current_y = new_x, new_y\n    \n    print(f\"{current_x+1} {current_y+1} {len(houses_passed)}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_a",
    "code_list": [
      "def main():\n    A, B, C, D = map(int, input().split())\n    \n    # Check if any number appears exactly twice\n    count_A = (A == B) + (A == C) + (A == D)\n    count_B = (B == A) + (B == C) + (B == D)\n    count_C = (C == A) + (C == B) + (C == D)\n    count_D = (D == A) + (D == B) + (D == C)\n    \n    if count_A == 2 or count_B == 2 or count_C == 2 or count_D == 2:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_b",
    "code_list": [
      "def main():\n    S = input().strip()\n    \n    # Precompute powers of 10 modulo 10^9+7\n    MOD = 10**9 + 7\n    pow10 = [1] * len(S)\n    for i in range(1, len(S)):\n        pow10[i] = (pow10[i-1] * 10) % MOD\n    \n    n = len(S)\n    dp = [[float('inf')] * (n+1) for _ in range(n+1)]\n    dp[0][0] = 0\n    \n    for i in range(n):\n        for j in range(i+1):\n            if dp[i][j] != float('inf'):\n                # Option 1: append current digit\n                new_j = j + 1\n                cost = 1 + (i - j) * 2\n                dp[new_j][new_j] = min(dp[new_j][new_j], dp[i][j] + cost)\n                \n                # Option 2: append '0'\n                cost = 1 + (i - j) * 2\n                dp[j][new_j] = min(dp[j][new_j], dp[i][j] + cost)\n    \n    result = float('inf')\n    for k in range(n+1):\n        if dp[k][k] < result:\n            result = dp[k][k]\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  }
]