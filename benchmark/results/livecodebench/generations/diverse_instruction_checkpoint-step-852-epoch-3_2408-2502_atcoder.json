[
  {
    "question_id": "abc365_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    first_max = -1\n    second_max = -1\n    \n    for num in arr:\n        if num > first_max:\n            second_max = first_max\n            first_max = num\n        elif num > second_max and num != first_max:\n            second_max = num\n            \n    print(second_max)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc365_a",
    "code_list": [
      "def main():\n    Y = int(input().strip())\n    \n    if (Y % 4 == 0 and Y % 100 != 0) or (Y % 400 == 0):\n        print(366)\n    else:\n        print(365)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    strings = data[1:1+n]\n    \n    # Find maximum length\n    max_len = 0\n    for s in strings:\n        if len(s) > max_len:\n            max_len = len(s)\n    \n    # Generate all possible vertical arrangements\n    def generate_vertical(arrangement):\n        if len(arrangement) == n:\n            yield ''.join(arrangement)\n            return\n            \n        for char in 'abcdefghijklmnopqrstuvwxyz*':\n            arrangement.append(char)\n            yield from generate_vertical(arrangement)\n            arrangement.pop()\n            \n    # Precompute prefix arrays\n    prefixes = []\n    for s in strings:\n        prefix = [None] * (n + 1)\n        for i in range(n + 1):\n            if i == 0:\n                prefix[i] = ''\n            else:\n                prefix[i] = prefix[i-1] + s[i-1]\n        prefixes.append(prefix)\n    \n    # Generate all vertical arrangements\n    valid_arrangements = set()\n    for arr in generate_vertical([]):\n        valid = True\n        for i in range(1, n + 1):\n            current_prefix = prefixes[i - 1][i:]\n            if current_prefix != arr[:len(current_prefix)]:\n                valid = False\n                break\n        if valid:\n            valid_arrangements.add(''.join(arr))\n    \n    # Sort by length descending, then lexicographically\n    sorted_arrangements = sorted(valid_arrangements, key=lambda x: (-len(x), x))\n    \n    # Print results\n    for t in sorted_arrangements:\n        print(t)\n\nif __name__ == '__main__':\n    main()"
    ]
  },
  {
    "question_id": "abc366_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    T = int(data[1])\n    A = int(data[2])\n    \n    if (T - A) % 2 == 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_a",
    "code_list": [
      "def main():\n    A, B, C = map(int, input().split())\n    \n    # Check if there's any overlap between sleep period and waking period\n    if max(A, B) < min(C - 1, 23):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_b",
    "code_list": [
      "def main():\n    x = float(input().strip())\n    \n    # Convert to string and remove trailing zeros after decimal point\n    str_x = \"{:.3f}\".format(x)\n    # Remove trailing zeros and check if we removed anything\n    cleaned_str = str_x.rstrip('0').rstrip('.')\n    \n    print(cleaned_str)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    k = int(data[1])\n    arr = list(map(int, data[2:2+n]))\n    \n    result = []\n    for i in range(k):\n        result.append(arr[-(i+1)])\n    for i in range(n - k):\n        result.append(arr[i])\n        \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_b",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    arr = list(map(int, input().split()))\n    \n    # Count initial ones\n    count_ones = sum(1 for num in arr if num == 1)\n    \n    # If all numbers are already zero, return 0\n    if count_ones == 0:\n        print(0)\n        return\n    \n    # Calculate total operations needed to make all zeros\n    total_operations = 0\n    while True:\n        # Find first non-zero element\n        i = 0\n        while i < len(arr) and arr[i] == 0:\n            i += 1\n        \n        if i == len(arr):\n            break\n            \n        # Count consecutive zeros after first non-zero element\n        j = i + 1\n        while j < len(arr) and arr[j] == 0:\n            j += 1\n            \n        # Add contribution: (j - i) * (count_ones - 1)\n        total_operations += (j - i) * (count_ones - 1)\n        \n        # Decrease all elements from i to j by 1\n        for k in range(i, j):\n            arr[k] -= 1\n            \n        # Update count of ones\n        count_ones = sum(1 for num in arr if num == 1)\n    \n    print(total_operations)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_a",
    "code_list": [
      "def main():\n    A, B = map(int, input().split())\n    \n    # Check if A or B is even\n    if A % 2 == 0 or B % 2 == 0:\n        print(1)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    min_fatigue = float('inf')\n    \n    # Try all initial positions for first key\n    for start_pos in range(101):\n        current_fatigue = 0\n        \n        # Process each note\n        for i in range(n):\n            pos = int(data[2*i + 1]) - 1  # Convert to 0-indexed\n            \n            # Calculate movement cost\n            move_cost = abs(start_pos - pos)\n            \n            # Update total fatigue\n            current_fatigue += move_cost\n            \n            # Determine which hand to use\n            if data[2*i + 2] == 'L':\n                # Use left hand\n                current_fatigue += abs(pos - start_pos)\n                start_pos = pos\n            else:  # 'R'\n                # Use right hand\n                current_fatigue += abs(pos - start_pos)\n                start_pos = pos\n                \n        if current_fatigue < min_fatigue:\n            min_fatigue = current_fatigue\n            \n    print(min_fatigue)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_a",
    "code_list": [
      "def main():\n    L, R = map(int, input().split())\n    \n    if L == 1 and R == 1:\n        print(\"Invalid\")\n    elif L == 1 or R == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    matrix = []\n    index = 1\n    for i in range(n):\n        row = list(map(int, data[index:index+n]))\n        matrix.append(row)\n        index += n\n    \n    current_element = 1\n    for i in range(1, n + 1):\n        current_element = matrix[current_element - 1][i - 1]\n    \n    print(current_element)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Initialize list to track which family has the earliest boy\n    earliest_boy_family = [None] * (n + 1)\n    \n    index = 2\n    for _ in range(m):\n        family_id = int(data[index])\n        gender = data[index + 1]\n        \n        index += 2\n        \n        if gender == 'M':\n            # This is a boy\n            if earliest_boy_family[family_id] is None:\n                # First boy in this family\n                earliest_boy_family[family_id] = True\n            elif earliest_boy_family[family_id]:\n                # Another boy in this family - not Taro\n                print(\"No\")\n                return\n                \n        else:  # Female\n            if earliest_boy_family[family_id] is not None:\n                # Already had a boy - not Taro\n                print(\"No\")\n                return\n                \n    # If we made it through all babies without finding conflicts, Taro!\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_a",
    "code_list": [
      "def main():\n    s_ab = input().strip()\n    s_ac = input().strip()\n    s_bc = input().strip()\n    \n    # Determine who is the oldest\n    if s_ab == '<':\n        oldest = 'A'\n    elif s_ac == '<':\n        oldest = 'B'\n    else:  # s_bc == '<'\n        oldest = 'C'\n    \n    # Determine who is the middle (second oldest)\n    if s_ab == '>':\n        middle = 'B' if oldest != 'A' else 'C'\n    elif s_ac == '>':\n        middle = 'A' if oldest != 'B' else 'C'\n    else:  # s_bc == '>'\n        middle = 'A' if oldest != 'C' else 'B'\n    \n    print(middle)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc372_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    result = []\n    for char in s:\n        if char != '.':\n            result.append(char)\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_a",
    "code_list": [
      "def main():\n    strings = []\n    for _ in range(12):\n        strings.append(input().strip())\n    \n    count = 0\n    for i in range(1, 13):\n        if len(strings[i-1]) == i:\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Create mapping from character to position\n    char_to_pos = {}\n    for i, ch in enumerate(s):\n        char_to_pos[ch] = i + 1\n    \n    # Calculate total distance\n    total_distance = 0\n    current_position = 1  # Start at 'A' (position 1)\n    \n    for ch in s:\n        pos = char_to_pos[ch]\n        distance = abs(pos - current_position)\n        total_distance += distance\n        current_position = pos\n    \n    print(total_distance)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_b",
    "code_list": [
      "def main():\n    S = input().strip()\n    T = input().strip()\n    \n    min_length = min(len(S), len(T))\n    \n    for i in range(min_length):\n        if S[i] != T[i]:\n            print(i + 1)\n            return\n    \n    # If all characters match up to the minimum length, compare lengths\n    if len(S) == len(T):\n        print(0)\n    else:\n        print(len(S))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    if s.endswith(\"san\"):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_b",
    "code_list": [
      "import math\nfrom collections import deque\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    points = []\n    index = 1\n    for i in range(n):\n        x = int(data[index]); y = int(data[index+1])\n        index += 2\n        points.append((x, y))\n    \n    # Calculate distances between consecutive points\n    dists = []\n    for i in range(n):\n        dx = points[i][0] - points[(i+1) % n][0]\n        dy = points[i][1] - points[(i+1) % n][1]\n        dists.append(math.sqrt(dx*dx + dy*dy))\n    \n    # Calculate distance from last point back to first point\n    start_to_end_dist = math.sqrt(points[0][0]**2 + points[0][1]**2)\n    dists.append(start_to_end_dist)\n    \n    # Find all distinct distances using Floyd-Warshall\n    INF = float('inf')\n    dist_mat = [[INF] * n for _ in range(n)]\n    for i in range(n):\n        dist_mat[i][i] = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            dist_mat[i][j] = dist_mat[j][i] = dists[i]\n    \n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist_mat[i][k] + dist_mat[k][j] < dist_mat[i][j]:\n                    dist_mat[i][j] = dist_mat[i][k] + dist_mat[k][j]\n    \n    # Check if all distances are integers\n    for i in range(n):\n        for j in range(n):\n            if not math.isclose(dist_mat[i][j], round(dist_mat[i][j])):\n                print(\"No\")\n                return\n    \n    # BFS from each vertex to find shortest paths\n    visited = [False] * n\n    parent = [-1] * n\n    min_dist = [float('inf')] * n\n    queue = deque()\n    \n    for start in range(n):\n        visited[start] = True\n        min_dist[start] = 0\n        queue.append(start)\n        \n        while queue:\n            u = queue.popleft()\n            for v in range(n):\n                if not visited[v] and dist_mat[u][v] != INF:\n                    visited[v] = True\n                    min_dist[v] = min(min_dist[v], min_dist[u] + dist_mat[u][v])\n                    parent[v] = u\n                    queue.append(v)\n    \n    # Check if all vertices have a path to themselves with minimum distance >= 0\n    valid = True\n    for i in range(n):\n        if min_dist[i] < 0:\n            valid = False\n            break\n    \n    if not valid:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    count = 0\n    for i in range(n - 2):\n        if s[i] == '#' and s[i+2] == '#':\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc376_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    c = int(data[1])\n    times = list(map(int, data[2:2+n]))\n    \n    count = 0\n    current_time = 0\n    \n    for t in times:\n        if t - current_time >= c:\n            count += 1\n            current_time = t\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_b",
    "code_list": [
      "def main():\n    grid = []\n    for _ in range(8):\n        grid.append(input().strip())\n    \n    count = 0\n    \n    # Check each cell\n    for i in range(8):\n        for j in range(8):\n            if grid[i][j] == '.':\n                valid = True\n                \n                # Check vertical capture\n                for k in range(i + 1, 8):\n                    if grid[k][j] == '#':\n                        valid = False\n                        break\n                \n                # Check horizontal capture\n                for k in range(j + 1, 8):\n                    if grid[i][k] == '#':\n                        valid = False\n                        break\n                \n                if valid:\n                    count += 1\n                    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Check if all characters are already correct\n    if s == \"ABC\":\n        print(\"Yes\")\n        return\n        \n    # Check if we have at least one 'A', one 'B', and one 'C'\n    has_A = 'A' in s\n    has_B = 'B' in s\n    has_C = 'C' in s\n    \n    if not (has_A and has_B and has_C):\n        print(\"No\")\n        return\n        \n    # Check if we can swap two adjacent characters to get \"ABC\"\n    for i in range(2):\n        if s[i] != 'A':\n            continue\n            \n        # Try swapping with B or C\n        if i < 2:  # We're not at the end\n            if s[i+1] == 'B':\n                new_string = list(s)\n                new_string[i], new_string[i+1] = new_string[i+1], new_string[i]\n                new_s = ''.join(new_string)\n                if new_s == \"ABC\":\n                    print(\"Yes\")\n                    return\n                    \n        if i > 0:  # We're not at the beginning\n            if s[i-1] == 'C':\n                new_string = list(s)\n                new_string[i], new_string[i-1] = new_string[i-1], new_string[i]\n                new_s = ''.join(new_string)\n                if new_s == \"ABC\":\n                    print(\"Yes\")\n                    return\n                    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Parse q_i and r_i\n    queries = []\n    index = 1\n    for _ in range(n):\n        q = int(data[index]); r = int(data[index+1])\n        index += 2\n        queries.append((q, r))\n    \n    # Parse Q\n    Q = int(data[index]); index += 1\n    \n    # Parse t_j and d_j\n    queries_data = []\n    for _ in range(Q):\n        t = int(data[index]); d = int(data[index+1])\n        index += 2\n        queries_data.append((t, d))\n    \n    # Precompute prefix sums for each type\n    prefix_sums = [{} for _ in range(n)]\n    for i in range(n):\n        q, r = queries[i]\n        prefix_sums[i][r] = 1\n        \n        for j in range(i + 1, n):\n            new_r = (r + q - 1) % q\n            prefix_sums[j][new_r] = prefix_sums[j].get(new_r, 0) + prefix_sums[i][r]\n    \n    # Process each query\n    results = []\n    for t, d in queries_data:\n        # Find earliest collection day >= d\n        min_day = float('inf')\n        for i in range(n):\n            q, r = queries[i]\n            current_r = (d - 1) % q + 1\n            count = prefix_sums[i].get(current_r, 0)\n            \n            # Check if this collection happens on or after day d\n            if count > 0 and current_r <= r:\n                min_day = min(min_day, (current_r + count - 1) % q + 1)\n        \n        results.append(str(min_day))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_a",
    "code_list": [
      "def main():\n    colors = [int(input()) for _ in range(4)]\n    freq = {}\n    \n    for color in colors:\n        if color not in freq:\n            freq[color] = 0\n        freq[color] += 1\n    \n    max_count = 0\n    for count in freq.values():\n        if count > max_count:\n            max_count = count\n            \n    print(max_count // 2)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, k = map(int, data[0].split())\n    s = data[1].strip()\n    \n    count = 0\n    max_count = 0\n    \n    for char in s:\n        if char == 'O':\n            count += 1\n        else:\n            count = 0\n            \n        if count >= k:\n            max_count += 1\n            \n    print(max_count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_a",
    "code_list": [
      "def main():\n    N = int(input().strip())\n    \n    # Extract digits\n    hundreds = N // 100\n    tens = (N // 10) % 10\n    units = N % 10\n    \n    # Form new numbers\n    num1 = 100 * tens + 10 * units + hundreds\n    num2 = 100 * units + 10 * hundreds + tens\n    \n    print(f\"{num1} {num2}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_a",
    "code_list": [
      "def main():\n    N = int(input().strip())\n    \n    # Convert to string to easily access individual digits\n    num_str = str(N)\n    \n    # Count occurrences of each digit\n    count_1 = num_str.count('1')\n    count_2 = num_str.count('2')\n    count_3 = num_str.count('3')\n    \n    # Check conditions\n    if count_1 == 1 and count_2 == 2 and count_3 == 3:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Find all occurrences of '|' and '-'\n    positions = []\n    for i, char in enumerate(s):\n        if char == '|':\n            positions.append(i)\n    \n    # If no '-' found, return empty sequence\n    if not positions:\n        print()\n        return\n    \n    # Extract lengths of segments\n    lengths = [positions[i] - positions[i-1] - 1 for i in range(1, len(positions))]\n    \n    # The last segment might be missing the trailing |\n    if positions[-1] < len(s) - 1:\n        lengths.append(len(s) - positions[-1] - 1)\n    \n    # Convert to list of numbers\n    result = [int(length / 2) for length in lengths]\n    \n    # Handle case where first element might be missing\n    if result[0] == 0:\n        result.pop(0)\n    \n    # Add remaining elements\n    for i in range(1, len(result)):\n        result.insert(0, int((result[i] + result[i-1]) / 2))\n    \n    # Remove duplicates and sort\n    unique_sorted = sorted(set(result))\n    \n    # Output the sequence\n    print(' '.join(map(str, unique_sorted)))\n\nif __name__ == '__main__':\n    main()"
    ]
  },
  {
    "question_id": "abc381_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    if len(s) != n:\n        print(\"No\")\n        return\n        \n    # Check if first character is '1'\n    if s[0] != '1':\n        print(\"No\")\n        return\n        \n    # Check if last character is '/'\n    if s[-1] != '/':\n        print(\"No\")\n        return\n        \n    # Count '/' characters\n    slash_count = 0\n    for char in s:\n        if char == '/':\n            slash_count += 1\n            \n    # Calculate expected middle position\n    mid_pos = (n + 1) // 2\n    \n    # Check if middle position has exactly one '/' character\n    if slash_count == 1 and mid_pos <= len(s) and mid_pos >= 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    n = len(s)\n    \n    # Check if length is even\n    if n % 2 != 0:\n        print(\"No\")\n        return\n    \n    # Count frequency of each character\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    \n    # Check if all characters appear exactly twice\n    for count in freq.values():\n        if count != 2:\n            print(\"No\")\n            return\n    \n    # Check if all pairs have matching characters\n    half_length = n // 2\n    valid_pairs = set()\n    \n    for i in range(half_length):\n        pair = s[i:i+2]\n        if pair[0] == pair[1]:\n            valid_pairs.add(pair)\n    \n    # If we have exactly half_length distinct pairs, it's valid\n    if len(valid_pairs) == half_length:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1].strip()\n    \n    # Count initial empty boxes\n    empty_count = s.count('.')\n    \n    for _ in range(d):\n        # Find all positions with '@' within current window\n        positions_with_at = []\n        for i in range(n - d + 1):\n            if s[i] == '@':\n                positions_with_at.append(i)\n        \n        # Remove positions that are too far away from the window\n        valid_positions = [pos for pos in positions_with_at if pos <= n - d]\n        \n        # If no valid positions, no change\n        if not valid_positions:\n            continue\n            \n        # Choose the first valid position (earliest)\n        chosen_pos = min(valid_positions)\n        \n        # Mark the chosen position as eaten\n        s = s[:chosen_pos] + '.' + s[chosen_pos+1:]\n    \n    print(empty_count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1].strip()\n    \n    result = []\n    for i in range(n):\n        if s[i] == '@':\n            # Check if there's a cookie to the right\n            has_right_cookie = False\n            for j in range(i + 1, n):\n                if s[j] == '@':\n                    has_right_cookie = True\n                    break\n            \n            if not has_right_cookie:\n                result.append('.')\n            else:\n                result.append('@')\n        else:\n            result.append('.')\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc383_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    times = []\n    volumes = []\n    \n    index = 1\n    for i in range(n):\n        t = int(data[index]); v = int(data[index + 1])\n        times.append(t)\n        volumes.append(v)\n        index += 2\n    \n    # Simulate the process\n    current_water = 0\n    current_time = 0\n    \n    for i in range(n):\n        start_time = times[i]\n        end_time = times[i] + volumes[i]\n        \n        # Calculate how much water leaks during this interval\n        leaking = max(0, current_time - start_time)\n        current_water -= leaking\n        \n        # Add the volume we're adding\n        current_water += volumes[i]\n        \n        # Update current time\n        current_time = end_time\n    \n    print(current_water)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    r = int(data[1])\n    \n    idx = 2\n    results = []\n    \n    for _ in range(n):\n        d_i = int(data[idx]); idx += 1\n        a_i = int(data[idx]); idx += 1\n        \n        if d_i == 1:  # Div. 1\n            if r >= 1600 and r <= 2799:\n                r += a_i\n        else:  # Div. 2\n            if r >= 1200 and r <= 2399:\n                r += a_i\n                \n        results.append(str(r))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, c1, c2 = data[0].split()\n    S = data[1]\n    \n    result = []\n    for char in S:\n        if char != c1:\n            result.append(c2)\n        else:\n            result.append(char)\n            \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_a",
    "code_list": [
      "def main():\n    A, B, C = map(int, input().split())\n    \n    total_sum = A + B + C\n    \n    if total_sum % 2 != 0:\n        print(\"No\")\n        return\n        \n    target = total_sum // 2\n    \n    # Check if we can form a subset with sum=target using only A's and B's\n    def can_form_subset_with_sum(target, count_A):\n        if target == 0:\n            return True\n            \n        for i in range(count_A + 1):\n            remaining = target - i * A\n            if remaining < 0:\n                continue\n                \n            if i <= count_B and can_form_subset_with_sum(remaining, count_B - i):\n                return True\n                \n        return False\n        \n    if can_form_subset_with_sum(target, A):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_b",
    "code_list": [
      "from collections import deque\nimport sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    H, W, X, Y = map(int, data[0].split())\n    \n    grid = []\n    for i in range(1, 1 + H):\n        grid.append(data[i].strip())\n    \n    T = data[-1]\n    \n    visited = set()\n    queue = deque()\n    start_x, start_y = X - 1, Y - 1\n    queue.append((start_x, start_y))\n    visited.add((start_x, start_y))\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    houses_passed = set()\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if not (1 <= nx <= H and 1 <= ny <= W):\n                continue\n                \n            if (nx, ny) in visited:\n                continue\n                \n            if grid[nx][ny] == '#':\n                continue\n                \n            if grid[nx][ny] == '@':\n                houses_passed.add((nx, ny))\n                \n            visited.add((nx, ny))\n            queue.append((nx, ny))\n            \n    print(f\"{X} {Y} {len(houses_passed)}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_a",
    "code_list": [
      "def main():\n    A, B, C, D = map(int, input().split())\n    \n    # Check if any number appears exactly twice\n    count_A = sum(1 for num in [A, B, C, D] if num == A)\n    count_B = sum(1 for num in [A, B, C, D] if num == B)\n    count_C = sum(1 for num in [A, B, C, D] if num == C)\n    count_D = sum(1 for num in [A, B, C, D] if num == D)\n    \n    if (count_A == 2 or count_B == 2 or count_C == 2 or count_D == 2):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_b",
    "code_list": [
      "def main():\n    S = input().strip()\n    \n    # Precompute powers of 10 modulo 10^9+7\n    MOD = 10**9 + 7\n    pow10 = [1] * len(S)\n    for i in range(1, len(S)):\n        pow10[i] = (pow10[i-1] * 10) % MOD\n    \n    n = len(S)\n    ans = 0\n    for i in range(n):\n        digit = int(S[i])\n        if digit == 0:\n            ans += pow10[n - 1 - i]\n        else:\n            ans += digit * pow10[n - 1 - i]\n            ans %= MOD\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  }
]